/**
 * *************************************************
 * Copyright (c) 2019, Grindrod Bank Limited
 * License MIT: https://opensource.org/licenses/MIT
 * **************************************************
 */
package org.tilkynna.common.utils;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;

import org.springframework.data.domain.Sort;
import org.springframework.data.domain.Sort.Direction;
import org.springframework.data.domain.Sort.Order;
import org.springframework.util.StringUtils;

/**
 * Based on Spring's SortHandlerMethodArgumentResolver as we are unable to use the standard functionality for Pageable provided by Spring. <br/>
 * Because our controller interface classes are being generated by the swagger codegen... there is currently not way of getting Pageable via this method. T
 */
// When wanting to sort on multiple fields you simply put the sort parameter multiple times in the URI.
// For example your/uri?sort=name,asc&sort=numberOfHands,desc.
// Spring Data is then capable of constructing a Pageable object with multiple sorts.
//
// https://docs.spring.io/spring-data/rest/docs/current/reference/html/
// sort: A collection of sort directives in the format ($propertyname,)+[asc|desc]?.
// You can control the direction of the sort by appending a comma (,) to the the property name plus either asc or desc.
// To sort the results by more than one property, keep adding as many sort=PROPERTY parameters as you need
public class ParseOrderByQueryParam {

    private static final String DEFAULT_PROPERTY_DELIMITER = ",";

    private ParseOrderByQueryParam() {
        throw new IllegalStateException("Utility class");
    }

    public static Sort resolveArgument(List<String> orderBy, String defaultSortField) {
        Sort defaultSort = Sort.by(Arrays.asList(new Order(Direction.ASC, defaultSortField)));

        // work around for odd codegen issue, not allowing arrays to be null
        orderBy = (orderBy != null && orderBy.get(0).contains("new ArrayList<>()")) ? null : orderBy;

        String[] directionParameter = orderBy != null ? orderBy.toArray(new String[0]) : null;
        // No parameter
        if (directionParameter == null) {
            return defaultSort;
        }

        // Single empty parameter, e.g "sort="
        if (directionParameter.length == 1 && !StringUtils.hasText(directionParameter[0])) {
            return defaultSort;
        }

        return parseParameterIntoSort(directionParameter, DEFAULT_PROPERTY_DELIMITER);
    }

    private static Sort parseParameterIntoSort(String[] source, String delimiter) {

        List<Order> allOrders = new ArrayList<>();

        boolean onlyOneOrderBy = false;
        // Spring already ...
        for (int i = 0; i < source.length; i++) {
            onlyOneOrderBy = !source[i].contains(DEFAULT_PROPERTY_DELIMITER);
        }

        if (onlyOneOrderBy) { // only 1 orderBy field has been used eg: ?orderBy=tag,desc
            String property = source[0];
            Direction direction = Direction.fromString(source[1]);
            allOrders.add(new Order(direction, property));
            return allOrders.isEmpty() ? null : Sort.by(allOrders);
        }

        for (String part : source) {

            if (part == null) {
                continue;
            }

            String[] elements = part.split(delimiter);

            Optional<Direction> direction = elements.length == 0 ? Optional.empty() : Direction.fromOptionalString(elements[elements.length - 1]);

            int lastIndex = direction.map(it -> elements.length - 1).orElseGet(() -> elements.length);

            for (int i = 0; i < lastIndex; i++) {
                toOrder(elements[i], direction).ifPresent(allOrders::add);
            }
        }

        return allOrders.isEmpty() ? Sort.unsorted() : Sort.by(allOrders);
    }

    private static Optional<Order> toOrder(String property, Optional<Direction> direction) {

        if (!StringUtils.hasText(property)) {
            return Optional.empty();
        }

        return Optional.of(direction.map(it -> new Order(it, property)).orElseGet(() -> Order.by(property)));
    }

}
